// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.29.3
// source: dispatcher/v1/dispatcher.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DispatcherAsync_UpdateFortuneTreeStatusCheck_FullMethodName = "/dispatcher.v1.DispatcherAsync/UpdateFortuneTreeStatusCheck"
	DispatcherAsync_UpdateCropStatusCheck_FullMethodName        = "/dispatcher.v1.DispatcherAsync/UpdateCropStatusCheck"
	DispatcherAsync_UpdateOnlineRewardTask_FullMethodName       = "/dispatcher.v1.DispatcherAsync/UpdateOnlineRewardTask"
	DispatcherAsync_TriggerUserRegistrationEvent_FullMethodName = "/dispatcher.v1.DispatcherAsync/TriggerUserRegistrationEvent"
	DispatcherAsync_TriggerUserLoginEvent_FullMethodName        = "/dispatcher.v1.DispatcherAsync/TriggerUserLoginEvent"
	DispatcherAsync_TriggerUserRechargeEvent_FullMethodName     = "/dispatcher.v1.DispatcherAsync/TriggerUserRechargeEvent"
	DispatcherAsync_TriggerUserWithdrawEvent_FullMethodName     = "/dispatcher.v1.DispatcherAsync/TriggerUserWithdrawEvent"
	DispatcherAsync_TriggerUserFriendActionEvent_FullMethodName = "/dispatcher.v1.DispatcherAsync/TriggerUserFriendActionEvent"
	DispatcherAsync_TriggerUserEvent_FullMethodName             = "/dispatcher.v1.DispatcherAsync/TriggerUserEvent"
	DispatcherAsync_TriggerHeartbeatEventFast_FullMethodName    = "/dispatcher.v1.DispatcherAsync/TriggerHeartbeatEventFast"
	DispatcherAsync_TriggerHeartbeatEventSlow_FullMethodName    = "/dispatcher.v1.DispatcherAsync/TriggerHeartbeatEventSlow"
)

// DispatcherAsyncClient is the client API for DispatcherAsync service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DispatcherAsyncClient interface {
	// 发财树状态检查，推送
	UpdateFortuneTreeStatusCheck(ctx context.Context, in *UpdateFortuneTreeStatusCheckReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 农场作物状态检查,推送
	UpdateCropStatusCheck(ctx context.Context, in *UpdateCropStatusCheckReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户在线时长奖励监测
	UpdateOnlineRewardTask(ctx context.Context, in *UpdateOnlineRewardTaskReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户注册事件触发
	TriggerUserRegistrationEvent(ctx context.Context, in *UserRegistrationEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户登录事件触发
	TriggerUserLoginEvent(ctx context.Context, in *UserLoginEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户充值事件触发
	TriggerUserRechargeEvent(ctx context.Context, in *UserRechargeEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户提现事件触发
	TriggerUserWithdrawEvent(ctx context.Context, in *UserWithdrawEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 用户触发事件给好友发送
	TriggerUserFriendActionEvent(ctx context.Context, in *UserFriendActionEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 指定用户发送
	TriggerUserEvent(ctx context.Context, in *TriggerUserEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 心跳检测事件触发 <每9秒触发一次>
	TriggerHeartbeatEventFast(ctx context.Context, in *HeartbeatEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 心跳检测事件触发 <每10分钟触发一次>
	TriggerHeartbeatEventSlow(ctx context.Context, in *HeartbeatEventReq, opts ...grpc.CallOption) (*DispatcherReply, error)
}

type dispatcherAsyncClient struct {
	cc grpc.ClientConnInterface
}

func NewDispatcherAsyncClient(cc grpc.ClientConnInterface) DispatcherAsyncClient {
	return &dispatcherAsyncClient{cc}
}

func (c *dispatcherAsyncClient) UpdateFortuneTreeStatusCheck(ctx context.Context, in *UpdateFortuneTreeStatusCheckReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_UpdateFortuneTreeStatusCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) UpdateCropStatusCheck(ctx context.Context, in *UpdateCropStatusCheckReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_UpdateCropStatusCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) UpdateOnlineRewardTask(ctx context.Context, in *UpdateOnlineRewardTaskReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_UpdateOnlineRewardTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserRegistrationEvent(ctx context.Context, in *UserRegistrationEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserRegistrationEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserLoginEvent(ctx context.Context, in *UserLoginEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserLoginEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserRechargeEvent(ctx context.Context, in *UserRechargeEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserRechargeEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserWithdrawEvent(ctx context.Context, in *UserWithdrawEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserWithdrawEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserFriendActionEvent(ctx context.Context, in *UserFriendActionEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserFriendActionEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerUserEvent(ctx context.Context, in *TriggerUserEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerUserEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerHeartbeatEventFast(ctx context.Context, in *HeartbeatEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerHeartbeatEventFast_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherAsyncClient) TriggerHeartbeatEventSlow(ctx context.Context, in *HeartbeatEventReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherAsync_TriggerHeartbeatEventSlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispatcherAsyncServer is the server API for DispatcherAsync service.
// All implementations must embed UnimplementedDispatcherAsyncServer
// for forward compatibility
type DispatcherAsyncServer interface {
	// 发财树状态检查，推送
	UpdateFortuneTreeStatusCheck(context.Context, *UpdateFortuneTreeStatusCheckReq) (*DispatcherReply, error)
	// 农场作物状态检查,推送
	UpdateCropStatusCheck(context.Context, *UpdateCropStatusCheckReq) (*DispatcherReply, error)
	// 用户在线时长奖励监测
	UpdateOnlineRewardTask(context.Context, *UpdateOnlineRewardTaskReq) (*DispatcherReply, error)
	// 用户注册事件触发
	TriggerUserRegistrationEvent(context.Context, *UserRegistrationEventReq) (*DispatcherReply, error)
	// 用户登录事件触发
	TriggerUserLoginEvent(context.Context, *UserLoginEventReq) (*DispatcherReply, error)
	// 用户充值事件触发
	TriggerUserRechargeEvent(context.Context, *UserRechargeEventReq) (*DispatcherReply, error)
	// 用户提现事件触发
	TriggerUserWithdrawEvent(context.Context, *UserWithdrawEventReq) (*DispatcherReply, error)
	// 用户触发事件给好友发送
	TriggerUserFriendActionEvent(context.Context, *UserFriendActionEventReq) (*DispatcherReply, error)
	// 指定用户发送
	TriggerUserEvent(context.Context, *TriggerUserEventReq) (*DispatcherReply, error)
	// 心跳检测事件触发 <每9秒触发一次>
	TriggerHeartbeatEventFast(context.Context, *HeartbeatEventReq) (*DispatcherReply, error)
	// 心跳检测事件触发 <每10分钟触发一次>
	TriggerHeartbeatEventSlow(context.Context, *HeartbeatEventReq) (*DispatcherReply, error)
	mustEmbedUnimplementedDispatcherAsyncServer()
}

// UnimplementedDispatcherAsyncServer must be embedded to have forward compatible implementations.
type UnimplementedDispatcherAsyncServer struct {
}

func (UnimplementedDispatcherAsyncServer) UpdateFortuneTreeStatusCheck(context.Context, *UpdateFortuneTreeStatusCheckReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFortuneTreeStatusCheck not implemented")
}
func (UnimplementedDispatcherAsyncServer) UpdateCropStatusCheck(context.Context, *UpdateCropStatusCheckReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCropStatusCheck not implemented")
}
func (UnimplementedDispatcherAsyncServer) UpdateOnlineRewardTask(context.Context, *UpdateOnlineRewardTaskReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOnlineRewardTask not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserRegistrationEvent(context.Context, *UserRegistrationEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserRegistrationEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserLoginEvent(context.Context, *UserLoginEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserLoginEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserRechargeEvent(context.Context, *UserRechargeEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserRechargeEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserWithdrawEvent(context.Context, *UserWithdrawEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserWithdrawEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserFriendActionEvent(context.Context, *UserFriendActionEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserFriendActionEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerUserEvent(context.Context, *TriggerUserEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerUserEvent not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerHeartbeatEventFast(context.Context, *HeartbeatEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerHeartbeatEventFast not implemented")
}
func (UnimplementedDispatcherAsyncServer) TriggerHeartbeatEventSlow(context.Context, *HeartbeatEventReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerHeartbeatEventSlow not implemented")
}
func (UnimplementedDispatcherAsyncServer) mustEmbedUnimplementedDispatcherAsyncServer() {}

// UnsafeDispatcherAsyncServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispatcherAsyncServer will
// result in compilation errors.
type UnsafeDispatcherAsyncServer interface {
	mustEmbedUnimplementedDispatcherAsyncServer()
}

func RegisterDispatcherAsyncServer(s grpc.ServiceRegistrar, srv DispatcherAsyncServer) {
	s.RegisterService(&DispatcherAsync_ServiceDesc, srv)
}

func _DispatcherAsync_UpdateFortuneTreeStatusCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFortuneTreeStatusCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).UpdateFortuneTreeStatusCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_UpdateFortuneTreeStatusCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).UpdateFortuneTreeStatusCheck(ctx, req.(*UpdateFortuneTreeStatusCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_UpdateCropStatusCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCropStatusCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).UpdateCropStatusCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_UpdateCropStatusCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).UpdateCropStatusCheck(ctx, req.(*UpdateCropStatusCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_UpdateOnlineRewardTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOnlineRewardTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).UpdateOnlineRewardTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_UpdateOnlineRewardTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).UpdateOnlineRewardTask(ctx, req.(*UpdateOnlineRewardTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserRegistrationEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegistrationEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserRegistrationEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserRegistrationEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserRegistrationEvent(ctx, req.(*UserRegistrationEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserLoginEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserLoginEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserLoginEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserLoginEvent(ctx, req.(*UserLoginEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserRechargeEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRechargeEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserRechargeEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserRechargeEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserRechargeEvent(ctx, req.(*UserRechargeEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserWithdrawEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserWithdrawEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserWithdrawEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserWithdrawEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserWithdrawEvent(ctx, req.(*UserWithdrawEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserFriendActionEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserFriendActionEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserFriendActionEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserFriendActionEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserFriendActionEvent(ctx, req.(*UserFriendActionEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerUserEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerUserEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerUserEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerUserEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerUserEvent(ctx, req.(*TriggerUserEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerHeartbeatEventFast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerHeartbeatEventFast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerHeartbeatEventFast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerHeartbeatEventFast(ctx, req.(*HeartbeatEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherAsync_TriggerHeartbeatEventSlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherAsyncServer).TriggerHeartbeatEventSlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherAsync_TriggerHeartbeatEventSlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherAsyncServer).TriggerHeartbeatEventSlow(ctx, req.(*HeartbeatEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DispatcherAsync_ServiceDesc is the grpc.ServiceDesc for DispatcherAsync service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DispatcherAsync_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dispatcher.v1.DispatcherAsync",
	HandlerType: (*DispatcherAsyncServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateFortuneTreeStatusCheck",
			Handler:    _DispatcherAsync_UpdateFortuneTreeStatusCheck_Handler,
		},
		{
			MethodName: "UpdateCropStatusCheck",
			Handler:    _DispatcherAsync_UpdateCropStatusCheck_Handler,
		},
		{
			MethodName: "UpdateOnlineRewardTask",
			Handler:    _DispatcherAsync_UpdateOnlineRewardTask_Handler,
		},
		{
			MethodName: "TriggerUserRegistrationEvent",
			Handler:    _DispatcherAsync_TriggerUserRegistrationEvent_Handler,
		},
		{
			MethodName: "TriggerUserLoginEvent",
			Handler:    _DispatcherAsync_TriggerUserLoginEvent_Handler,
		},
		{
			MethodName: "TriggerUserRechargeEvent",
			Handler:    _DispatcherAsync_TriggerUserRechargeEvent_Handler,
		},
		{
			MethodName: "TriggerUserWithdrawEvent",
			Handler:    _DispatcherAsync_TriggerUserWithdrawEvent_Handler,
		},
		{
			MethodName: "TriggerUserFriendActionEvent",
			Handler:    _DispatcherAsync_TriggerUserFriendActionEvent_Handler,
		},
		{
			MethodName: "TriggerUserEvent",
			Handler:    _DispatcherAsync_TriggerUserEvent_Handler,
		},
		{
			MethodName: "TriggerHeartbeatEventFast",
			Handler:    _DispatcherAsync_TriggerHeartbeatEventFast_Handler,
		},
		{
			MethodName: "TriggerHeartbeatEventSlow",
			Handler:    _DispatcherAsync_TriggerHeartbeatEventSlow_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dispatcher/v1/dispatcher.proto",
}

const (
	DispatcherTimer_CycleFertileTreeStatusCheck_FullMethodName = "/dispatcher.v1.DispatcherTimer/CycleFertileTreeStatusCheck"
	DispatcherTimer_CycleCropStageUpdate_FullMethodName        = "/dispatcher.v1.DispatcherTimer/CycleCropStageUpdate"
)

// DispatcherTimerClient is the client API for DispatcherTimer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DispatcherTimerClient interface {
	// 发财树状态检查
	CycleFertileTreeStatusCheck(ctx context.Context, in *DispatcherReq, opts ...grpc.CallOption) (*DispatcherReply, error)
	// 农场作物状态更新
	CycleCropStageUpdate(ctx context.Context, in *DispatcherReq, opts ...grpc.CallOption) (*DispatcherReply, error)
}

type dispatcherTimerClient struct {
	cc grpc.ClientConnInterface
}

func NewDispatcherTimerClient(cc grpc.ClientConnInterface) DispatcherTimerClient {
	return &dispatcherTimerClient{cc}
}

func (c *dispatcherTimerClient) CycleFertileTreeStatusCheck(ctx context.Context, in *DispatcherReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherTimer_CycleFertileTreeStatusCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatcherTimerClient) CycleCropStageUpdate(ctx context.Context, in *DispatcherReq, opts ...grpc.CallOption) (*DispatcherReply, error) {
	out := new(DispatcherReply)
	err := c.cc.Invoke(ctx, DispatcherTimer_CycleCropStageUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispatcherTimerServer is the server API for DispatcherTimer service.
// All implementations must embed UnimplementedDispatcherTimerServer
// for forward compatibility
type DispatcherTimerServer interface {
	// 发财树状态检查
	CycleFertileTreeStatusCheck(context.Context, *DispatcherReq) (*DispatcherReply, error)
	// 农场作物状态更新
	CycleCropStageUpdate(context.Context, *DispatcherReq) (*DispatcherReply, error)
	mustEmbedUnimplementedDispatcherTimerServer()
}

// UnimplementedDispatcherTimerServer must be embedded to have forward compatible implementations.
type UnimplementedDispatcherTimerServer struct {
}

func (UnimplementedDispatcherTimerServer) CycleFertileTreeStatusCheck(context.Context, *DispatcherReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CycleFertileTreeStatusCheck not implemented")
}
func (UnimplementedDispatcherTimerServer) CycleCropStageUpdate(context.Context, *DispatcherReq) (*DispatcherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CycleCropStageUpdate not implemented")
}
func (UnimplementedDispatcherTimerServer) mustEmbedUnimplementedDispatcherTimerServer() {}

// UnsafeDispatcherTimerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispatcherTimerServer will
// result in compilation errors.
type UnsafeDispatcherTimerServer interface {
	mustEmbedUnimplementedDispatcherTimerServer()
}

func RegisterDispatcherTimerServer(s grpc.ServiceRegistrar, srv DispatcherTimerServer) {
	s.RegisterService(&DispatcherTimer_ServiceDesc, srv)
}

func _DispatcherTimer_CycleFertileTreeStatusCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatcherReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherTimerServer).CycleFertileTreeStatusCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherTimer_CycleFertileTreeStatusCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherTimerServer).CycleFertileTreeStatusCheck(ctx, req.(*DispatcherReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatcherTimer_CycleCropStageUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatcherReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatcherTimerServer).CycleCropStageUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatcherTimer_CycleCropStageUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatcherTimerServer).CycleCropStageUpdate(ctx, req.(*DispatcherReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DispatcherTimer_ServiceDesc is the grpc.ServiceDesc for DispatcherTimer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DispatcherTimer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dispatcher.v1.DispatcherTimer",
	HandlerType: (*DispatcherTimerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CycleFertileTreeStatusCheck",
			Handler:    _DispatcherTimer_CycleFertileTreeStatusCheck_Handler,
		},
		{
			MethodName: "CycleCropStageUpdate",
			Handler:    _DispatcherTimer_CycleCropStageUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dispatcher/v1/dispatcher.proto",
}
